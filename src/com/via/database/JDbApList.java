package com.via.database;

import java.text.DecimalFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.math.BigInteger;

public class JDbApList {
    private JDatabase dbInst;
    private String tableName;
    private String tableNameInQuotes;
    private final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
    private final BigInteger maxInt32 = new BigInteger("4294967296");               // 2 ^ 32
    private final BigInteger maxInt64 = new BigInteger("18446744073709551616");     // 2 ^ 64
    private final String[] tableDefinition = {
    		"ID INT GENERATED BY DEFAULT AS IDENTITY, ",
    		"AC_PUBLIC_IP   VARCHAR(20) NOT NULL, ",
    		"AP_PUBLIC_IP   VARCHAR(20) NOT NULL, ",
    		"AP_NAME        VARCHAR(20) NOT NULL, ",
            "SCHD_TIME      TIMESTAMP NOT NULL, ",
            "REC_TIME       TIMESTAMP NOT NULL, ",
            "OCT_TX_TOT     VARCHAR(20), ",
            "OCT_RX_TOT     VARCHAR(20) "
    };
    
    public JDbApList(final JDatabase database, final String tableName) {
        this.dbInst = database;
        this.tableName = tableName;
        this.tableNameInQuotes = "\"" + tableName + "\"";
    }
    
    public boolean isTableExisted() {
        return dbInst.isTableExisted(tableName);
    }
    
    public boolean createTable() {
        String definition = "";
        for (String s : tableDefinition) definition += s;

        return dbInst.createTable(tableName, definition);
    }

    public boolean add(final String[] value) {
        return dbInst.insert(tableName, value);
    }
    
    public boolean add(final String[][] values) {
        return dbInst.insert(tableName, values);
    }
    
    public String[] getFirstByPort(final String ip) {
        String ipAddrExpression = "AP_PUBLIC_IP = '" + ip + "'";
        //String portIdExpression = "PORT_ID = " + port_id;
        return dbInst.getFirst(tableName, "ID", new String[]{ ipAddrExpression});
    }
    
    public String[] getLastByPort(final String ip) {
        String ipAddrExpression = "AP_PUBLIC_IP = '" + ip + "'";
        //String portIdExpression = "PORT_ID = " + port_id;
        return dbInst.getLast(tableName, "ID", new String[]{ ipAddrExpression});
    }
    
    public String[] getBoundaryTimeByPort(final String ip) {
        String[] firstRecord = getFirstByPort(ip);
        String[] lastRecord = getLastByPort(ip);
        
        if (firstRecord != null && lastRecord != null) {
        	//System.out.println("firstRecord"+Arrays.toString(firstRecord));
        	//System.out.println("firstRecord"+Arrays.toString(lastRecord));
            return new String[] { firstRecord[5], lastRecord[5] };      // NOTE: care about the index
        }
        
        return null;
    }

    /**
     * Return a set of array that contents timing and data rate of Rx/Tx octets.
     * 
     */
    public String[][] getRxTxOctetRateHistory(final String acIp, final String ip, final String startTime, final String endTime) {
        String[] selectedColumns = { "OCT_RX_TOT", "OCT_TX_TOT" };

        return getHistoryInRate(acIp, ip, startTime, endTime, selectedColumns);
    }
    
    private String[][] getHistoryInRate(
    		final String acIp, 
            final String ip,
            final String startTime,
            final String endTime,
            final String[] selectedColumns) {
        
        Calendar calendar = Calendar.getInstance();
        String baseStartTime = "2000-01-01 00:00:00.000"; // use this time as the far past time
        String baseEndTime = sdf.format(calendar.getTime()); // use current time as the latest time
        String acIpAddrExpression = "AC_PUBLIC_IP = '" + acIp + "'";
        String ipAddrExpression = "AP_PUBLIC_IP = '" + ip + "'";
        String startTimeExpression = "REC_TIME >= '" + (startTime != null && !startTime.isEmpty() ? startTime : baseStartTime) + "'";
        String endTimeExpression = "REC_TIME <= '" + (endTime != null && !endTime.isEmpty() ? endTime : baseEndTime) + "'";
        
        double timeForRate = System.currentTimeMillis();
        String selectedString = "REC_TIME, " + selectedColumns[0];
        for (int i = 1; i < selectedColumns.length; i++) selectedString += ", " + selectedColumns[i];
        String query = String.format("SELECT %s FROM %s WHERE %s AND %s AND %s AND %s",
                selectedString, tableNameInQuotes, acIpAddrExpression, ipAddrExpression, startTimeExpression, endTimeExpression);
        //System.out.println(query);
        String[][] result = dbInst.getByQuery(query);
        //System.out.println("Result data read from database:");
        // JTools.print(result, true);
        String[][] output = null;
        int lengthPerRecord = selectedColumns.length + 1;        // add one space to put rec_time in
        
        if (result != null && result.length > 0 && result[0].length == lengthPerRecord) {        // the length of first record should be correct
            output = new String[result.length][lengthPerRecord];

            output[0][0] = result[0][0];                    // rec_time
            for (int j = 1; j < result[0].length; j++) output[0][j] = "0";      // fill 0 to all lines in first record

            for (int i = 1; i < result.length; i++) {
                output[i][0] = result[i][0];                // rec_time
                if (result[i].length != lengthPerRecord) {
                    for (int j = 1; j < lengthPerRecord; j++) output[i][j] = "0";      // skip this record if length is wrong
                    continue;
                }
                
                long diffTime = 0;;
                try {
                    diffTime = (sdf.parse(output[i][0]).getTime() - sdf.parse(output[i - 1][0]).getTime()) / 1000;    // the diff between current and previous
                }
                catch (ParseException e) {
                    System.out.println("getHistoryInRate calculate diffTime failed.");
                    for (int j = 1; j < lengthPerRecord; j++) output[i][j] = "0";
                    continue;
                }
                
                for (int j = 1; j < lengthPerRecord; j++) {
                    try {
                        BigInteger curr = new BigInteger(result[i][j]);
                        BigInteger prev = new BigInteger(result[i - 1][j]);
                        BigInteger diff = curr.subtract(prev);
                        if (curr.compareTo(prev) < 0) {                 // loop occurred
                            BigInteger max =  maxInt32;
                            diff = max.subtract(prev).add(curr);
                        }
                        float rate = (diff.floatValue() * 8) / (float)diffTime / 1000;    // use 1 kbps = 1000 bps
                        if(diffTime > 3600){
                        	output[i-1][j] = "0";
                        	output[i][j] = "0";
                        }else{
                        	output[i][j] = String.valueOf(rate);
                        }
                    }
                    catch (NumberFormatException e) {
                        System.out.println("getHistoryInRate parsing BigInteger failed.");
                        output[i][j] = "0";
                    }
                }
            }

            //System.out.println("Output data that is parsing after read from database:");
            //JTools.print(output, true);
        }
        else {
            System.out.println("getHistoryInRate get data from db incorrect.");
        }
        System.out.println("getHistoryInRate uses " + (System.currentTimeMillis() - timeForRate) / 1000 + " sec.");
        
        return output;
    }

	public ArrayList<String[]> getRxTxOctetTraffic(final String acIp, final String startTime, final String endTime) {
		double prevTime = System.currentTimeMillis();

		String[] selectedColumns = { "REC_TIME", "AP_PUBLIC_IP", "AP_NAME", "OCT_RX_TOT", "OCT_TX_TOT" };
		String selectedString = selectedColumns[0];
		for (int i = 1; i < selectedColumns.length; i++)
			selectedString += ", " + selectedColumns[i];
		String acIpAddrExpression = "AC_PUBLIC_IP = '" + acIp + "'";

		Calendar calendar = Calendar.getInstance();
		String baseStartTime = "2000-01-01 00:00:00.000"; // use this time as the far past time
		String baseEndTime = sdf.format(calendar.getTime()); // use current time as the latest time
		String startTimeExpression = "REC_TIME >= '" + (startTime != null && !startTime.isEmpty() ? startTime : baseStartTime) + "'";
		String endTimeExpression = "REC_TIME <= '" + (endTime != null && !endTime.isEmpty() ? endTime : baseEndTime) + "'";

		String query = String.format("SELECT %s FROM %s WHERE %s AND AP_PUBLIC_IP <> '0.0.0.0' AND AP_PUBLIC_IP <> 'null' AND OCT_RX_TOT <> 'null' AND OCT_TX_TOT <> 'null' AND %s AND %s ORDER BY AP_PUBLIC_IP,REC_TIME ASC", selectedString, tableNameInQuotes, acIpAddrExpression, startTimeExpression, endTimeExpression);
		//System.out.println(query);

		String[][] result = dbInst.getByQuery(query);

		ArrayList<String[]> ApTrafficList = new ArrayList<String[]>();

		if (result != null) {
			String ip_tmp = "";

			ArrayList<String[]> ipfilter_array = new ArrayList<String[]>();

			for (int i = 0; i < result.length; i++) {
				//System.out.println(result[i][0] + ", " + result[i][1] + ", " + result[i][2] + result[i][3] + ", " + result[i][4]);

				if (!result[i][1].equals(ip_tmp)) {
					if (ipfilter_array.size() > 0) {
						ApTrafficList.add(getTrafficSUM(ipfilter_array));
					}

					ip_tmp = result[i][1];
					ipfilter_array = new ArrayList<String[]>();
					ipfilter_array.add(result[i]);
				} else {
					ipfilter_array.add(result[i]);

					if (i == result.length - 1) {
						ApTrafficList.add(getTrafficSUM(ipfilter_array));
					}
				}
			}
		}

		System.out.println("Get AP Rx Tx Traffic, costs: " + (System.currentTimeMillis() - prevTime) / 1000 + " sec.");

		return ApTrafficList;
	}

	private String[] getTrafficSUM(final ArrayList<String[]> ipfilter_array) {
		long rx_tmp = -1L;
		long rx_sum = 0L;
		long tx_tmp = -1L;
		long tx_sum = 0L;

		for (int j = 0; j < ipfilter_array.size(); j++) {
			//System.out.println(ipfilter_array.get(j)[0] + ", " + ipfilter_array.get(j)[1] + ", " + ipfilter_array.get(j)[2] + ", " + ipfilter_array.get(j)[3] + ", " + ipfilter_array.get(j)[4]);

			if (rx_tmp == -1L) {
				//System.out.println(ipfilter_array.get(j)[0] + ", " + ipfilter_array.get(j)[1] + ", " + ipfilter_array.get(j)[2] + ", " + ipfilter_array.get(j)[3] + ", " + ipfilter_array.get(j)[4]);
			} else if (Long.parseLong(ipfilter_array.get(j)[3]) < rx_tmp) {
				rx_sum = rx_sum + Long.parseLong(ipfilter_array.get(j)[3]);
				//System.out.println(Long.parseLong(ipfilter_array.get(j)[3]));
			} else {
				rx_sum = rx_sum + (Long.parseLong(ipfilter_array.get(j)[3]) - rx_tmp);
				//System.out.println(Long.parseLong(ipfilter_array.get(j)[3]) + " - " + rx_tmp + " = " + (Long.parseLong(ipfilter_array.get(j)[3]) - rx_tmp));
			}

			rx_tmp = Long.parseLong(ipfilter_array.get(j)[3]);

			if (tx_tmp == -1L) {
				//System.out.println(ipfilter_array.get(j)[0] + ", " + ipfilter_array.get(j)[1] + ", " + ipfilter_array.get(j)[2] + ", " + ipfilter_array.get(j)[3] + ", " + ipfilter_array.get(j)[4]);
			} else if (Long.parseLong(ipfilter_array.get(j)[4]) < tx_tmp) {
				tx_sum = tx_sum + Long.parseLong(ipfilter_array.get(j)[4]);
				// System.out.println(Integer.parseInt(ipfilter_array.get(j)[4]));
			} else {
				tx_sum = tx_sum + (Long.parseLong(ipfilter_array.get(j)[4]) - tx_tmp);
				// System.out.println(Long.parseLong(ipfilter_array.get(j)[4]) +
				// " - " + tx_tmp + " = " +
				// (Long.parseLong(ipfilter_array.get(j)[4]) - tx_tmp));
			}

			tx_tmp = Long.parseLong(ipfilter_array.get(j)[4]);
		}

		String[] output = new String[5];
		DecimalFormat df = new DecimalFormat("#.##");
		output[0] = ipfilter_array.get(0)[1];
		output[1] = ipfilter_array.get(0)[2];
		output[2] = df.format(rx_sum / (double) 1000000);
		//System.out.println("rx_sum:" + rx_sum + ", " + rx_sum / 1000000);
		output[3] = df.format(tx_sum / (double) 1000000);
		//System.out.println("tx_sum:" + tx_sum + ", " + tx_sum / 1000000);
		output[4] = df.format((rx_sum / (double) 1000000 + tx_sum / (double) 1000000));
		//System.out.println("rx_sum + tx_sum:" + (rx_sum + tx_sum) + ", " + (rx_sum + tx_sum) / 1000000);

		return output;
	}
}
